<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Genetic.js String Solver</title>
    <script src="lib/genetic.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
</head>
<body>

<h1>Genetic String Solver</h1>

<textarea id="quote" style="width: 300px; height: 100px;">Insanity is doing the same thing over and over again and expecting different results</textarea>

<button id="solve">Solve</button>

<table id="results">
    <thead>
    <tr>
        <th>Generation</th>
        <th>Fitness</th>
        <th>Solution</th>
    </tr>
    </thead>
    <tbody style="font-family: monospace;">
    </tbody>
</table>

<script>

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    //var theWindow = window;

    var genetic = Genetic.create();

    genetic.optimize = Genetic.Optimize.Maximize;
    genetic.select1 = Genetic.Select1.Tournament2;
    genetic.select2 = Genetic.Select2.Tournament2;

    var resultOfLastGame = -1;

    function callback(val) {
        //alert(val)
        resultOfLastGame = val;


        // TODO We might need to replace resultOfLastGame with an array or dict
    }

    genetic.seed = function() {

        function randomString(len) {
            var text = "";
            var charset = "0123456789";
            for(var i=0;i<len;i++)
                text += charset.charAt(Math.floor(Math.random() * charset.length));

            return text;
        }

        ///////////////////////////////////////////////////////////////////////
        // Cole Added
        let max = 500;
        let min = 0;
        let result = [];
        for(let i = 0; i < 5; i++) {
            result.push(Math.random() * (max - min) + min);
        }
        return result;
        //////////////////////////////////////////////////////////////////////

        // create random strings that are equal in length to solution
        return randomString(this.userData["solution"].length);
    };

    genetic.mutate = function(entity) {

        //$http

        //console.log("MUTATE: " + theWindow);

        function replaceAt(str, index, character) {
            return str.substr(0, index) + character + str.substr(index+character.length);
        }

        // chromosomal drift
        ///////////////////////////////////////////////////////////////////////
        // Cole Added
        let growth_speed = 10;
        for(let i = 0; i < 5; i++) {
            entity[i] += Math.random() * (growth_speed * 2) - growth_speed
        }
        return entity;
        //////////////////////////////////////////////////////////////////////
        var i = Math.floor(Math.random()*entity.length)
        return replaceAt(entity, i, String.fromCharCode(entity.charCodeAt(i) + (Math.floor(Math.random()*2) ? 1 : -1)));
    };

    genetic.crossover = function(mother, father) {


        //console.log("CROSSOVER: " + theWindow);

        // two-point crossover
        var len = mother.length;
        var ca = Math.floor(Math.random()*len);
        var cb = Math.floor(Math.random()*len);
        if (ca > cb) {
            var tmp = cb;
            cb = ca;
            ca = tmp;
        }

        ///////////////////////////////////////////////////////////////////////
        // Cole
        var son = father.slice(0, ca).concat(mother.slice(ca, cb), father.slice(cb));
        var daughter = mother.slice(0, ca).concat(father.slice(ca, cb), mother.slice(cb));
        // var son = father.substr(0,ca) + mother.substr(ca, cb-ca) + father.substr(cb);
        // var daughter = mother.substr(0,ca) + father.substr(ca, cb-ca) + mother.substr(cb);
        //////////////////////////////////////////////////////////////////////

        return [son, daughter];
    };

    var count = 0;

    genetic.fitness = async function(entity) {

        //genetic.window




        //console.log(window);

       // $("#results tbody").prepend("TYLER");


        await sleep(300*count++);


       //$(document).open("main.html?a=0&b=40&c=3&d=150&e=0.13");

        window.open("index.html?a=0&b=40&c=3&d=150&e=0.13", "DINO"+count++, "height=300,width=900");

        console.log(resultOfLastGame)

        while(resultOfLastGame < 0) {
            await sleep(2000);
        }

        return resultOfLastGame;



        ///////////////////////////////////////////////////////////////////////
        // Cole Added
        // TODO: This is where we need to add the code to open the game with the params, get the score, and close the game.
        // For now, returning a random fitness score
        return Math.floor(Math.random() * 10000);
        //////////////////////////////////////////////////////////////////////
        var fitness = 0;

        console.log("HI");

        alert("HI");

        //window.open("main.html?a=0&b=40&c=3&d=150&e=0.13");

        var i;
        for (i=0;i<entity.length;++i) {
            // increase fitness for each character that matches
            if (entity[i] == this.userData["solution"][i])
                fitness += 1;

            // award fractions of a point as we get warmer
            fitness += (127-Math.abs(entity.charCodeAt(i) - this.userData["solution"].charCodeAt(i)))/50;
        }

        return fitness;
    };

    genetic.generation = function(pop, generation, stats) {
        ///////////////////////////////////////////////////////////////////////
        // Cole Added
        let stop_score = 10000;
        return stats.minimum < stop_score;
        //////////////////////////////////////////////////////////////////////
        // stop running once we've reached the solution
        return pop[0].entity != this.userData["solution"];
    };

    genetic.notification = function(pop, generation, stats, isFinished) {

        function lerp(a, b, p) {
            return a + (b-a)*p;
        }

        var value = pop[0].entity;
        this.last = this.last||value;

        if (pop != 0 && value == this.last)
            return;


        // var solution = [];
        // var i;
        // for (i=0;i<value.length;++i) {
        //     var diff = value.charCodeAt(i) - this.last.charCodeAt(i);
        //     var style = "background: transparent;";
        //     if (diff > 0) {
        //         style = "background: rgb(0,200,50); color: #fff;";
        //     } else if (diff < 0) {
        //         style = "background: rgb(0,100,50); color: #fff;";
        //     }
        //
        //     solution.push("<span style=\"" + style + "\">" + value[i] + "</span>");
        // }

        var buf = "";
        buf += "<tr>";
        buf += "<td>" + generation + "</td>";
        buf += "<td>" + pop[0].fitness.toPrecision(5) + "</td>";
        // buf += "<td>" + solution.join("") + "</td>";
        buf += "<td>" + "A: " + pop[0].entity[0] + " B: " + pop[0].entity[1] + " C: " + pop[0].entity[2] + " D: " + pop[0].entity[3] + " E: " + pop[0].entity[4] + "</td>";
        buf += "</tr>";
        $("#results tbody").prepend(buf);

        this.last = value;
    };


    $(document).ready(function () {
        $("#solve").click(function () {

            $("#results tbody").html("");

            var config = {
                "iterations": 400
                , "size": 8
                , "crossover": 0.3
                , "mutation": 0.3
                , "skip": 2
            };

            var userData = {
                "solution": $("#quote").val()
            };

            genetic.evolve(config, userData);
        });
    });

</script>


</body>
</html>